//! Field sources generated by currents in wires and loops.
//!
//! Implements quasi-static Biot–Savart for line currents and the vector potential
//! for time-harmonic cases (E = -jω A in Lorenz gauge).

use crate::constants::VACUUM_PERMEABILITY;
use crate::math::{C3, CScalar, R3, Scalar};

/// A straight wire segment from `start` to `end` in meters.
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct WireSegment3D {
    /// Start point (meters).
    pub start: R3,
    /// End point (meters).
    pub end: R3,
}

impl WireSegment3D {
    /// Length of the segment in meters.
    #[must_use]
    pub fn length(&self) -> Scalar {
        (self.end - self.start).norm()
    }
}

/// A line current confined to a wire segment, carrying a complex phasor current.
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct LineCurrent {
    /// Geometry of the current path.
    pub segment: WireSegment3D,
    /// Complex current phasor in amperes (A).
    pub current: CScalar,
}

/// Calculates magnetic flux density B (tesla) at `point` due to a single straight segment
/// with current `I`, via midpoint quadrature with `samples` subdivisions.
#[must_use]
pub fn magnetic_field_segment(point: R3, segment: &WireSegment3D, current: CScalar, samples: usize) -> C3 {
    let dl = (segment.end - segment.start) / samples as Scalar;
    let mu = VACUUM_PERMEABILITY;
    let coeff = CScalar::new(mu / (4.0 * std::f64::consts::PI), 0.0) * current;
    let mut b = C3::zeros();
    for k in 0..samples {
        let mid = segment.start + dl * (k as Scalar + 0.5);
        let r = point - mid;
        let r_norm = r.norm();
        if r_norm <= Scalar::EPSILON {
            continue; // skip singular contribution
        }
        let cross = dl.cross(&r) / (r_norm * r_norm * r_norm);
        b += cross.map(|v| CScalar::new(v, 0.0));
    }
    b * coeff
}

/// Closed-form magnetic flux density for a finite straight segment if well-conditioned.
/// Falls back to zero if the perpendicular distance is too small (caller can retry numerically).
#[must_use]
pub fn magnetic_field_segment_closed_form(point: R3, segment: &WireSegment3D, current: CScalar) -> Option<C3> {
    let v = segment.end - segment.start;
    let len = v.norm();
    if len <= Scalar::EPSILON {
        return Some(C3::zeros());
    }
    let u = v / len;
    let r1 = segment.start - point; // vector from point to start
    let r2 = segment.end - point; // vector from point to end
    let r_perp = (point - segment.start) - u * u.dot(&(point - segment.start));
    let rho = r_perp.norm();
    if rho <= 1e-9 {
        return None;
    }
    let z1 = r1.dot(&u);
    let z2 = r2.dot(&u);
    let s1 = z1 / (rho.hypot(z1));
    let s2 = z2 / (rho.hypot(z2));
    let coeff = CScalar::new(VACUUM_PERMEABILITY / (4.0 * std::f64::consts::PI), 0.0) * current;
    // Direction follows right-hand rule: u × r_perp
    let dir = u.cross(&r_perp);
    let dir_norm = dir.norm();
    if dir_norm <= Scalar::EPSILON {
        return None;
    }
    let b_mag = (s2 - s1) / rho;
    let unit = dir / dir_norm;
    let b_vec = unit * b_mag;
    Some(b_vec.map(|x| CScalar::new(x, 0.0)) * coeff)
}

/// Calculates vector potential A (weber per meter) at `point` due to a single segment
/// using midpoint quadrature with `samples` subdivisions: A = μ0 I / (4π) ∫ dl / r.
#[must_use]
pub fn vector_potential_segment(point: R3, segment: &WireSegment3D, current: CScalar, samples: usize) -> C3 {
    let dl = (segment.end - segment.start) / samples as Scalar;
    let mu = VACUUM_PERMEABILITY;
    let coeff = CScalar::new(mu / (4.0 * std::f64::consts::PI), 0.0) * current;
    let mut a = C3::zeros();
    for k in 0..samples {
        let mid = segment.start + dl * (k as Scalar + 0.5);
        let r = point - mid;
        let r_norm = r.norm();
        if r_norm <= Scalar::EPSILON {
            continue;
        }
        let dl_over_r = dl / r_norm;
        a += dl_over_r.map(|v| CScalar::new(v, 0.0));
    }
    a * coeff
}

/// Computes B from multiple line currents at `point` with adaptive sampling.
#[must_use]
pub fn magnetic_field_from_lines(point: R3, lines: &[LineCurrent]) -> C3 {
    let mut b = C3::zeros();
    for lc in lines {
        if let Some(bc) = magnetic_field_segment_closed_form(point, &lc.segment, lc.current) {
            b += bc;
        } else {
            let l = lc.segment.length();
            let d = distance_point_to_segment(point, &lc.segment).max(1e-6);
            let m = ((l / d).ceil() as usize).clamp(20, 1200);
            b += magnetic_field_segment(point, &lc.segment, lc.current, m);
        }
    }
    b
}

/// Computes A from multiple line currents at `point` with adaptive sampling.
#[must_use]
pub fn vector_potential_from_lines(point: R3, lines: &[LineCurrent]) -> C3 {
    let mut a = C3::zeros();
    for lc in lines {
        let l = lc.segment.length();
        let d = distance_point_to_segment(point, &lc.segment).max(1e-6);
        let m = ((l / d).ceil() as usize).clamp(20, 800);
        a += vector_potential_segment(point, &lc.segment, lc.current, m);
    }
    a
}

/// Time-harmonic electric field approximated via E = -jω A given the angular frequency `omega`.
#[must_use]
pub fn electric_field_from_vector_potential(a: C3, omega: Scalar) -> C3 {
    let j_omega = CScalar::new(0.0, -omega);
    a * j_omega
}

/// Distance from point to segment.
#[must_use]
pub fn distance_point_to_segment(p: R3, seg: &WireSegment3D) -> Scalar {
    let v = seg.end - seg.start;
    let w = p - seg.start;
    let c1 = w.dot(&v);
    if c1 <= 0.0 {
        return (p - seg.start).norm();
    }
    let c2 = v.dot(&v);
    if c2 <= Scalar::EPSILON {
        return (p - seg.start).norm();
    }
    if c2 <= c1 {
        return (p - seg.end).norm();
    }
    let b = c1 / c2;
    let pb = seg.start + v * b;
    (p - pb).norm()
}

#[cfg(test)]
mod tests {
    use super::*;
    use approx::assert_relative_eq;

    #[test]
    fn b_field_matches_long_wire_near_center() {
        // Long wire along z-axis from z=-5 to +5, current 1 A.
        let seg = WireSegment3D {
            start: R3::new(0.0, 0.0, -5.0),
            end: R3::new(0.0, 0.0, 5.0),
        };
        let lines = [LineCurrent { segment: seg, current: CScalar::new(1.0, 0.0) }];
        // Observation point at radius rho = 0.1 m from axis, z=0.
        let p = R3::new(0.1, 0.0, 0.0);
        let b = magnetic_field_from_lines(p, &lines);
        let b_mag = (b[0].norm().powi(2) + b[1].norm().powi(2) + b[2].norm().powi(2)).sqrt();
        // Infinite-wire reference: μ0 I / (2π ρ)
        let ref_val = VACUUM_PERMEABILITY / (2.0 * std::f64::consts::PI * 0.1);
        // Expect within ~2% for finite length
        assert!((b_mag / ref_val - 1.0).abs() < 0.05);
    }

    #[test]
    fn closed_form_matches_numeric_segment() {
        let seg = WireSegment3D {
            start: R3::new(-0.5, 0.0, 0.0),
            end: R3::new(0.5, 0.0, 0.0),
        };
        let p = R3::new(0.0, 0.2, 0.0);
        let i = CScalar::new(2.0, 0.0);
        let bn = magnetic_field_segment(p, &seg, i, 2000);
        let bc = magnetic_field_segment_closed_form(p, &seg, i).unwrap();
        let err = ((bn[0] - bc[0]).norm() + (bn[1] - bc[1]).norm() + (bn[2] - bc[2]).norm())
            / (bn[0].norm() + bn[1].norm() + bn[2].norm()).max(1e-12);
        assert!(err < 1e-4, "relative error too large: {err}");
    }

    #[test]
    fn e_field_from_a_scales_with_frequency() {
        let a = C3::new(CScalar::new(1.0, 0.0), CScalar::new(0.0, 0.0), CScalar::new(0.0, 0.0));
        let e = electric_field_from_vector_potential(a, 2.0);
        assert_relative_eq!(e[0].im, -2.0, epsilon = 1e-12);
    }
}
